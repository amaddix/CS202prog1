# CS202prog1/ Ashley Maddix/ Winter Q 2018

In the first program in CS 202, we are tasked in creating a program that will show all the various routes to Mt. Hood. Each potential path we could travel will contain information on the total length of the path and the estimated time travel time. Each road will have equally spaced markers that will show the volume of cars that this road contains until the next marker, the number of accidents, and a weather update. The way my program will calculate the initial weather will use the random number generator to find a number 1-4 where each number is a different weather state. My program will use the weather to find the amount of traffic and accidents. Assuming that a sunny day will have a higher volume of traffic and a low amount of car accidents, and a day with freezing rain would have less initial traffic but a much higher number of car accidents. In this program the user will have the opportunity to show and save the path that they’ve taken, and the information from each marker they passed on that path.

In order to achieve this program design I will ideally have 5 classes. Three of those classes will be included in my hierarchy to contain the information to be saved in my data structures, and the two others will manage the data structures. My base class will save the current weather, so it will have an int that will help tell what the weather state is. It will also have a function to display the data members, change the data member, and a function to randomly set the initial weather. Derived from this class will be my traffic class, which will inherit the current weather and use that data to find information on the current volume of cars and amount of accidents. This class will also contain functions that will display this information, change this information, use the weather data to set the traffic data members, and use the traffic information to find an estimate for how many people are at the ski lodge that day. The last derived class will act as the markers on the road to show these updates. It will have an int to show its location on this road, and being derived from the weather and traffic class, it will inherit all their information as well. This function will act as a node for our data structures and will have functions to set the data, display all the data information, return the next marker, and set the next marker, connect two nodes and delete all the data. 

The last two classes that my program will manage my data structures. The first will control a array of linear linked lists, where each index will show a different route the user could take to get to their destination, and the nodes attached to each index will be a marker on the road which will allow the user to get regular updates on the weather and traffic through their trip. This class will need a marker ** data member to create an array of linear linked lists, and an int to keep track of how many routes have been entered. It will also have functions to display all the markers from each trip, display the makers from one specific route, and delete the list. The last class I will create will manage a linear linked list of markers, where each node shows a marker that the user passed on their trip. This class will have functions to display the whole trip, display the information from a marker at a specific location, and delete list. 

Ultimately my use of object oriented programming will help prevent me from have to create setter and getter functions in each class. Where I normally would need to when dealing with ‘has a’ relationships (because I cannot access that classes memory directly from another class), when creating a hierarchy and deriving a class from another I will have access to the base classes data and functions. 


EFFICIENCY WRITE UP

I think that both data structures that I used in this program worked well for the purpose that they were intended for. In order to save 10- mile markers for each route leading to Mt. hood, I used an array of linear linked list. This data structure allows me to keep track of all the possible routes, saving them in each index of my array. And for each index / route I will have a node giving updates for every 10 miles. I think that this data structure was the best option for what I was hoping to do. My second data structure was just a linear linked list, and this one just managed one chosen route (taken from my array of linear linked lists). I do also think that this data structure was the past choice for this program, although an doubly linked list could end up working well also, if I wanted to make functionality showing the route going back. There was one aspect of my data structures that I realized towards the end could potentially save me a little time. If I had created my array of linear linked list as an array of path objects (where a path has a node * ) it could have called the path class to manage each marker in the list, instead of having to make extra functions within my route class. 

I think all the classes in my program served clear responsibilities and did well managing its own data members. Specifically the classes within my hierarch, which includes the weather class, traffic class, and marker class (where weather is my base class, and traffic is derived from it. Then my marker (node) class was derived from the traffic class). Apart from any hierarchy in my program, I also had my path class (managing a linear linked list), and my routes class (managing the array of linear linked lists). These classes would not really benefit from including them in a hierarchy, although they do have a ‘has a’ relationship with the marker class. With this specific program, I don't think I can imagine a different design that would make this program more object oriented. But if I had been given more time, and wished to make more functionality I could definitely see some additional classes that would benefit from being included within my hierarchy (or in a new one of its own). But for what was expected from this program, I'm pretty happy and satisfied with the efficiency and end result of this program. 

GDB WRITE UP

During program 1, I found that GDB significantly help me to identify problems with my code. Many of these errors would have normally taken up much of my time to find the exact problem area, I was able to run it though a couple of times and find the exact spot in my code that segfaulted. And in this process, being able to determine if the correct functions and / or constructors were being called. One specific problem that I ran into was that I was getting a segfault whenever I tried to create a new node. It was hard for me to figure out exactly what was causing this error, but after running my code through GDB a few time, I was able to see that my code was crashing due to my map constructor being called. This allowed me to be able to focus in on that function ( and in the end found that I was attempting to create memory for more index’s of my array then initially allocated). That being said, I felt frustrated at many points when my program would crash before I could get a good idea of where exactly it was that was the problem. Because of this I think that just having a better idea of the common tools used while running my program through GDB would be really helpful, and hopefully make the debugging process even more smooth!
